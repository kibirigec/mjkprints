import { supabase, getFileUploadById } from '../../../lib/supabase'
import jwt from 'jsonwebtoken'
import crypto from 'crypto'

// File serving configurations
const SIGNED_URL_EXPIRY = 3600 // 1 hour in seconds
const DOWNLOAD_TRACKING_ENABLED = true
const MAX_DOWNLOAD_ATTEMPTS = 10 // Per file per day per IP

// Rate limiting for downloads (simple in-memory store)
const downloadRateLimit = new Map()
const RATE_LIMIT_WINDOW = 24 * 60 * 60 * 1000 // 24 hours
const RATE_LIMIT_MAX_DOWNLOADS = 100 // Per IP per day

const checkDownloadRateLimit = (ip) => {
  const now = Date.now()
  const key = `download_${ip}`
  
  if (!downloadRateLimit.has(key)) {
    downloadRateLimit.set(key, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
    return { allowed: true, remaining: RATE_LIMIT_MAX_DOWNLOADS - 1 }
  }
  
  const entry = downloadRateLimit.get(key)
  
  if (now > entry.resetTime) {
    downloadRateLimit.set(key, { count: 1, resetTime: now + RATE_LIMIT_WINDOW })
    return { allowed: true, remaining: RATE_LIMIT_MAX_DOWNLOADS - 1 }
  }
  
  if (entry.count >= RATE_LIMIT_MAX_DOWNLOADS) {
    return { allowed: false, remaining: 0, resetTime: entry.resetTime }
  }
  
  entry.count++
  return { allowed: true, remaining: RATE_LIMIT_MAX_DOWNLOADS - entry.count }
}

// Generate signed download token
const generateDownloadToken = (fileId, filePath, expiresIn = SIGNED_URL_EXPIRY) => {
  const payload = {
    fileId,
    filePath,
    type: 'download',
    exp: Math.floor(Date.now() / 1000) + expiresIn
  }
  
  const secret = process.env.JWT_SECRET || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  return jwt.sign(payload, secret)
}

// Verify download token
const verifyDownloadToken = (token) => {
  try {
    const secret = process.env.JWT_SECRET || process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    return jwt.verify(token, secret)
  } catch (error) {
    return null
  }
}

// Track download analytics
const trackDownload = async (fileId, clientInfo) => {
  if (!DOWNLOAD_TRACKING_ENABLED) return

  try {
    const { error } = await supabase
      .from('download_analytics')
      .insert([
        {
          file_id: fileId,
          ip_address: clientInfo.ip,
          user_agent: clientInfo.userAgent,
          referrer: clientInfo.referrer,
          downloaded_at: new Date().toISOString()
        }
      ])

    if (error) {
      console.error('Download tracking error:', error)
      // Don't fail the download if tracking fails
    }
  } catch (error) {
    console.error('Download tracking error:', error)
  }
}

// Validate access permissions
const validateAccess = async (fileId, clientInfo) => {
  try {
    // Get file record
    const fileUpload = await getFileUploadById(fileId)
    if (!fileUpload) {
      return { allowed: false, reason: 'File not found' }
    }

    // Check if file processing is completed
    if (fileUpload.processing_status !== 'completed') {
      return { allowed: false, reason: 'File not ready for download' }
    }

    // For now, allow all downloads (in production you might want to check:)
    // - User authentication
    // - Purchase verification  
    // - Download limits
    // - File permissions
    
    return {
      allowed: true,
      fileUpload
    }
  } catch (error) {
    console.error('Access validation error:', error)
    return { allowed: false, reason: 'Access validation failed' }
  }
}

export default async function handler(req, res) {
  const { path: filePath, token, preview, thumbnail } = req.query
  
  // Only allow GET requests
  if (req.method !== 'GET') {
    res.setHeader('Allow', ['GET'])
    return res.status(405).json({ error: 'Method not allowed' })
  }

  // Get client information
  const clientIP = req.headers['x-forwarded-for'] || 
                   req.headers['x-real-ip'] || 
                   req.connection.remoteAddress || 
                   'unknown'

  const clientInfo = {
    ip: clientIP,
    userAgent: req.headers['user-agent'] || 'unknown',
    referrer: req.headers.referer || req.headers.referrer || null
  }

  try {
    // Rate limiting
    const rateLimit = checkDownloadRateLimit(clientIP)
    res.setHeader('X-RateLimit-Limit', RATE_LIMIT_MAX_DOWNLOADS)
    res.setHeader('X-RateLimit-Remaining', rateLimit.remaining)
    
    if (!rateLimit.allowed) {
      res.setHeader('X-RateLimit-Reset', new Date(rateLimit.resetTime).toISOString())
      return res.status(429).json({ 
        error: 'Too many download requests',
        details: `Maximum ${RATE_LIMIT_MAX_DOWNLOADS} downloads per day allowed`
      })
    }

    // Parse file path
    const pathArray = Array.isArray(filePath) ? filePath : [filePath]
    const fullPath = pathArray.join('/')

    // Handle different file types
    let storageBucket = 'mjk-prints-storage'
    let storagePath = fullPath
    let fileId = null

    // Parse path to extract file ID and determine type
    if (fullPath.startsWith('pdfs/')) {
      // Direct PDF file access
      const pathParts = fullPath.split('/')
      if (pathParts.length >= 2) {
        const filename = pathParts[1]
        const fileIdMatch = filename.match(/^(\d+)_/)
        if (fileIdMatch) {
          fileId = fileIdMatch[1]
        }
      }
    } else if (fullPath.startsWith('previews/') || fullPath.startsWith('thumbnails/')) {
      // Preview or thumbnail access
      const pathParts = fullPath.split('/')
      if (pathParts.length >= 2) {
        fileId = pathParts[1]
      }
    }

    // For secured downloads, verify token
    if (!preview && !thumbnail && token) {
      const tokenData = verifyDownloadToken(token)
      if (!tokenData) {
        return res.status(401).json({ 
          error: 'Invalid download token',
          details: 'The download link has expired or is invalid'
        })
      }
      
      fileId = tokenData.fileId
      storagePath = tokenData.filePath
    }

    // Validate access permissions
    if (fileId) {
      const accessCheck = await validateAccess(fileId, clientInfo)
      if (!accessCheck.allowed) {
        return res.status(403).json({ 
          error: 'Access denied',
          details: accessCheck.reason
        })
      }
    }

    // Get signed URL from Supabase Storage
    const { data: signedUrlData, error: signedUrlError } = await supabase.storage
      .from(storageBucket)
      .createSignedUrl(storagePath, SIGNED_URL_EXPIRY)

    if (signedUrlError) {
      console.error('Signed URL generation error:', signedUrlError)
      return res.status(404).json({ 
        error: 'File not found',
        details: 'The requested file could not be located'
      })
    }

    // Track the download if it's a main file (not preview/thumbnail)
    if (fileId && !preview && !thumbnail) {
      await trackDownload(fileId, clientInfo)
    }

    // For direct file serving, redirect to signed URL
    if (req.query.redirect !== 'false') {
      res.redirect(302, signedUrlData.signedUrl)
      return
    }

    // For API response, return signed URL
    res.status(200).json({
      success: true,
      downloadUrl: signedUrlData.signedUrl,
      expiresAt: new Date(Date.now() + SIGNED_URL_EXPIRY * 1000).toISOString(),
      fileInfo: fileId ? {
        id: fileId,
        type: preview ? 'preview' : thumbnail ? 'thumbnail' : 'original'
      } : null
    })

  } catch (error) {
    console.error('File serving error:', error)

    // Handle specific error types
    if (error.message.includes('File not found')) {
      return res.status(404).json({ 
        error: 'File not found',
        details: 'The requested file does not exist'
      })
    }

    if (error.message.includes('Access validation failed')) {
      return res.status(500).json({ 
        error: 'Access validation error',
        details: 'Unable to validate file access permissions'
      })
    }

    // Generic error response
    res.status(500).json({ 
      error: 'File serving failed',
      details: 'An unexpected error occurred while serving the file'
    })
  }
}

// Helper function to generate secure download links (can be used by other API routes)
export const generateSecureDownloadUrl = (fileId, filePath, expiresIn = SIGNED_URL_EXPIRY) => {
  const token = generateDownloadToken(fileId, filePath, expiresIn)
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'
  return `${baseUrl}/api/files/${filePath}?token=${token}`
}

// Helper function for preview URLs
export const generatePreviewUrl = (fileId, size = 'medium') => {
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'
  return `${baseUrl}/api/files/previews/${fileId}/page-1-${size}.jpg?preview=true`
}

// Helper function for thumbnail URLs
export const generateThumbnailUrl = (fileId, page = 1) => {
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'
  return `${baseUrl}/api/files/thumbnails/${fileId}/page-${page}.jpg?thumbnail=true`
}